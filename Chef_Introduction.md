#Overview of CHEF

Chef is a configuration management tool written in Ruby and Erlang. It uses a pure-Ruby, domain-specific language (DSL) for writing system configuration "recipes".

Chef is a powerful automation platform that transforms complex infrastructure into code, bringing your servers and services to life. Whether you’re operating in the cloud, on-premises, or a hybrid, Chef automates how applications are configured, deployed, and managed across your network, no matter its size.

The user writes "recipes" that describe how Chef manages server applications and utilities (Apache HTTP Server,MySQL etc) and how they are configured. These recipes describe a series of resources that should be in a particular state.

State contains information on packages that should be installed, services that should be running, or files that should be written.

Chef is built with features for achieving desired state, centralized modeling of IT infrastructure, and resource primitives that serve as building blocks. These very same concepts allow Chef to handle the most difficult infrastructure challenges on the planet. Anything that can run the chef-client can be managed by Chef.

Chef can run in client/server mode or in a standalone configuration named "chef-solo". In client/server mode, the Chef client sends various attributes about the node to the Chef server. The server uses Solr to index these attributes and provides an API for clients to query this information. Chef recipes query the attributes and use the resulting data to configure the node.

#Components of CHEF

![alt text](https://github.com/pkdevaraj/Presentations/blob/gh-pages/Chef%20Images/ChefComponents.png "ChefComponents")

The above figure shows the relationships between the various elements of Chef, including the nodes, the server, premium features of the server, and the workstation. These elements together provide the chef-client the information and instructions required do its job.

Components of Chef include the following

#####WORKSTATIONS
One (or more) workstations are configured to allow users to write, test and manage cookbooks.
Cookbooks are uploaded to the Chef server from the workstation.Some of these are company specific and the rest could are available on the Chef Supermarket.

Ruby is the programming language that is the authoring syntax for cookbooks.

#####CHEF CLIENT
A chef-client is installed on every node that is under management by Chef. The chef-client performs all of the configuration tasks that are specified by the run-list and will pull down any required configuration data from the Chef server as it is needed during the chef-client run.

A node is any machine (physical, virtual, cloud, network device, etc) that is managed by Chef.

#####CHEF SERVER

The Chef server is a hub of information. Cookbooks and policy settings are uploaded to the Chef server by users from workstations.CHef also offers Chef management console web user interface, through which policy settings can be maintained on the Chef server itself.

The chef-client connects to the Chef server from the node on which it is installed to get configuration data, perform searches of historical chef-client run data, and then pull down the necessary configuration data. After the chef-client run is finished, the chef-client uploads updated run data to the Chef server and uploads data generated by audit-mode,and finally generates the reporting data.

Chef management console is the user interface for the Chef server which is used to manage data bags, attributes, run-lists, roles, environments, and cookbooks, and also to configure role-based access for users and groups.

####CHEF ANALYTICS

Chef Analytics provides real-time visibility into the processing on the Chef server, including what’s changing, who made those changes, and when they occurred. Details are tracked by the chef-client during the chef-client run.

These details are uploaded to the Chef server at the end of the chef-client run. This data is then used to build reports, run rules against the output of audit-mode, generate notifications based on the results of auditing, and visibility into messages which were generated during the chef-client run.


